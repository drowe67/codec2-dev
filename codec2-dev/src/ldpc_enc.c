/* RA encoder  program;  Bill,  March 2016 
   Using the elegant back substitution of RA LDPC codes. 
   This version does not store the data in bytes! */


#include <stdio.h>
#include <stdlib.h>

#define Nibits 2064
#define Npbits 516
#define Nwt     12

/* generated by ldpc_fsk_lib.m:ldpc_decode() */

#include "ldpc_code.h"

unsigned char  ibits[Nibits];    // info array 
unsigned char  pbits[Npbits];    // parity array 

void encode()   {
    unsigned int   p, i, tmp, par, prev=0;
    int ind;

    for (p=0; p<Npbits; p++) {
        par = 0; 

        for (i=0; i<Nwt; i++) {
            ind = (int)H_rows[p + i*Npbits];
            par = par + ibits[ind-1];
        }

        tmp = par + prev;

        tmp &= 1;    // only retain the lsb 
        prev = tmp; 
        pbits[p] =tmp; 
    }
}

int main(void)
{
  short  k;
  unsigned int x;

  printf("Test C Encoder\n");
  
  FILE *infp, *opfp;
  infp = fopen("dat_in2064.txt", "r");   // read info bits from file   
  if (infp == NULL) {printf("Unable to open file.\n"); exit(1);} 
 
  for (k=0; k<Nibits; k++)     { 
      fscanf(infp, "%u\n", &x);
      ibits[k] = x; 
    }
  fclose(infp);  

  encode();  

  opfp = fopen("dat_op2064.bin", "wb");   // write par bits to file
  if (opfp == NULL) {printf("Unable to output file.\n"); exit(1);}  
  for (k=0; k<Nibits; k++)
      fwrite(&ibits[k], sizeof(char), 1, opfp); 
  for (k=0; k<Npbits; k++)
      fwrite(&pbits[k], sizeof(char), 1, opfp); 
  fclose(opfp); 

  return 1;
}
