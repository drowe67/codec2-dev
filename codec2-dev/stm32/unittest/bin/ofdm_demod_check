#!/usr/bin/env python3
""" ofdm_demod_check

    - Convert stm32 output to octave text foramt
      (stm32 does not have memory for this)

    - ...

    """

import numpy as np
import struct
import os
import sys


##############################################################################
# Read Octave text file
##############################################################################

def read_octave_text(fname):
    data = {}
    with open(fname, "r") as f:
      for line in f:
        if (line[0:8] == '# name: '):
          var = line.split()[2]
          line = next(f)
          if (line.startswith('# type: matrix')):
            line = next(f)
            rows = int(line.split()[2])
            line = next(f)
            cols = int(line.split()[2])
            data[var] = np.empty((rows, cols), np.float32)
            # Read rows one at a time
            for row in range(rows):
              line = next(f)
              data[var][row] = np.fromstring(line, np.float32, cols, ' ')

          elif (line.startswith('# type: complex matrix')):
            line = next(f)
            rows = int(line.split()[2])
            line = next(f)
            cols = int(line.split()[2])
            data[var] = np.empty((rows, cols), np.complex64)
            # Read rows one at a time
            for row in range(rows):
              line = next(f)
              # " (r,i) (r,i) ..."
              for tpl in line.split():
                 real, imag = tpl.strip('(,)').split(',')
                 data[var][row][col] = float(real) + (1j * float(imag))
        # end for
      # end with
    return(data)


##############################################################################
# Main
##############################################################################

#### Read stm32 diag data, syms, amps for each frame
# TODO: don't use hardcoded values...
payload_syms_log_stm32 = np.zeros((100, 112), np.complex64)
payload_amps_log_stm32 = np.zeros((100, 112), np.float32)
with open('stm_diag.raw', 'rb') as f:
    row = 0
    while True:
        # syms
        buf = f.read(112 * 8)
        if (len(buf) < (112 * 8)): break
        row_lst = struct.unpack('<224f', buf)
        ary = np.array(row_lst, np.float32)
        ary.dtype = np.complex64
        payload_syms_log_stm32[row] = ary
        # amps
        buf = f.read(112 * 4)
        if (len(buf) < (112 * 4)): break
        row_lst = struct.unpack('<112f', buf)
        ary = np.array(row_lst, np.float32)
        payload_amps_log_stm32[row] = ary
        #
        row += 1
        if (row >= 100): break


#### Write out in octave text format as 2 matricies
with open('ofdm_demod_log.txt', 'w') as f:

    # syms
    rows = payload_syms_log_stm32.shape[0]
    cols = payload_syms_log_stm32.shape[1]
    f.write('# name: payload_syms_log_stm32\n')
    f.write('# type: complex matrix\n')
    f.write('# rows: {}\n'.format(rows))
    f.write('# columns: {}\n'.format(cols))
    for row in range(rows):
        for col in range(cols):
            f.write(' ({},{})'.format(
                payload_syms_log_stm32[row][col].real,
                payload_syms_log_stm32[row][col].imag
                ))
        f.write('\n')

    # amps
    rows = payload_amps_log_stm32.shape[0]
    cols = payload_amps_log_stm32.shape[1]
    f.write('\n')
    f.write('# name: payload_amps_log_stm32\n')
    f.write('# type: matrix\n')
    f.write('# rows: {}\n'.format(rows))
    f.write('# columns: {}\n'.format(cols))
    for row in range(rows):
        for col in range(cols):
            f.write(' {}'.format(
                payload_amps_log_stm32[row][col]
                ))
        f.write('\n')


#### Read ref data
ref_data = read_octave_text('ofdm_demod_ref_log.txt')

#### Compare

# Find smallest common sunset
hgt = min(payload_syms_log_stm32.shape[0], ref_data['payload_syms_log_c'].shape[0])
wid = min(payload_syms_log_stm32.shape[1], ref_data['payload_syms_log_c'].shape[1])
print('comparing {} cols of {} rows'.format(hgt, wid))

ref =  ref_data['payload_syms_log_c'][:hgt][:wid]
dat =  payload_syms_log_stm32[:hgt][:wid]

diffs = ref - dat
#print(ref[0])
#print(dat[0])
#print(diffs[0])
#print(np.amin(diffs))
#print(np.amax(diffs))
#print(np.average(diffs))
